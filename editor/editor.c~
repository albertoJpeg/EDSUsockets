#include "editor.h"
#include "comun.h"
#include "edsu_comun.h"
#include <netdb.h>
#include <pthread.h>

int activar_notificacion(void);

int generar_evento(const char *tema, const char *valor)
{
  ENT ent;
  if(obtener_entorno(&ent)==-1)
    return -1;
    
  int sckt;
  if((sckt = conectar(&ent))==-1)
    return -1;
  
  TOPIC_MSG msg;
  size_t msg_sz=sizeof(TOPIC_MSG);
  bzero((char*)&msg, msg_sz);

  /* Enviamos mensaje de creación de tema */
  msg.op = GENEV;
  sprintf(msg.tp_nam, "%s", tema);
  sprintf(msg.tp_val, "%s", valor);

  unsigned char *buf = 0;
  msg_sz = serialize(&msg, &buf);

  ssize_t tam;
  while((tam=send(sckt, buf, msg_sz, 0))>0);

  unsigned char buff[4096] = {0};
  unsigned char resp[MAX_REC_SZ];
  int offset = 0;

  while((tam=recv(sckt, (void*)resp, MAX_REC_SZ, 0))>0)
    {
      memcpy(buff + offset, &buf, (size_t)tam);
      offset+=tam;
    }

  TOPIC_MSG *msgI;
  msgI = deserialize(buff, (size_t)offset);
  
  if(msgI->op==ERROR)
    {
      fprintf(stderr, "EDITOR: Error al crear tema\n");
      return -1;
    }
  
  close(sckt);

  if (activar_notificacion() == -1)
    {
      fprintf("Error ");
      return -1;
    }
  
  return 0;

}

/* solo para la version avanzada */
int crear_tema(const char *tema)
{
  ENT ent;
  obtener_entorno(&ent);
  int sckt;
  sckt = conectar(&ent);
  
  TOPIC_MSG msg;
  size_t msg_sz=sizeof(TOPIC_MSG);
  bzero((char*)&msg, msg_sz);

  /* Enviamos mensaje de creación de tema */
  msg.op = CREAT;
  sprintf(msg.tp_nam, "%s", tema);

  unsigned char *buf = 0;
  msg_sz = serialize(&msg, &buf);

  ssize_t tam;
  while((tam=send(sckt, buf, msg_sz, 0))>0);

  unsigned char buff[4096] = {0};
  unsigned char resp[MAX_REC_SZ];
  int offset = 0;

  while((tam=recv(sckt, (void*)resp, MAX_REC_SZ, 0))>0)
    {
      memcpy(buff + offset, &buf, (size_t)tam);
      offset+=tam;
    }

  TOPIC_MSG *msgI;
  msgI = deserialize(buff, (size_t)offset);
  
  if(msgI->op==ERROR)
    {
      fprintf(stderr, "EDITOR: Error al crear tema\n");
      return -1;
    }
  
  close(sckt);
  return 0;
}

/* solo para la version avanzada */
int eliminar_tema(const char *tema)
{
  ENT ent;
  obtener_entorno(&ent);
  int sckt;
  sckt = conectar(&ent);
  
  TOPIC_MSG msg;
  size_t msg_sz=sizeof(TOPIC_MSG);
  bzero((char*)&msg, msg_sz);

  /* Enviamos mensaje de eliminación de tema */
  msg.op = ELIMT;
  sprintf(msg.tp_nam, "%s", tema);

  unsigned char *buf = 0;
  msg_sz = serialize(&msg, &buf);

  ssize_t tam;
  while((tam=send(sckt, buf, msg_sz, 0))>0);

  unsigned char buff[4096] = {0};
  unsigned char resp[MAX_REC_SZ];
  int offset = 0;

  while((tam=recv(sckt, (void*)resp, MAX_REC_SZ, 0))>0)
    {
      memcpy(buff + offset, &buf, (size_t)tam);
      offset+=tam;
    }

  TOPIC_MSG *msgI;
  msgI = deserialize(buff, (size_t)offset);
  
  if(msgI->op==ERROR)
    {
      fprintf(stderr, "EDITOR: Error al eliminar tema\n");
      return -1;
    }
  
  close(sckt);
  return 0;
}

int activar_notificacion(void)
{
  SOCKADDR_IN cli_addr;
  int sckt, port = PUERTO_LIBRE;
  if((sckt = abrir_puerto_escucha(port, &cli_addr))==-1)
    return -1;
  
  
  pthread_t notif;
  if(pthread_create(&notif, NULL, recibir_notif, (void*)sckt) != 0)
    {
      perror("Error");
      return -1;
    }
}

void *recibir_notif(void *sckt)
{
  socklen_t addr_sz = sizeof(SOCKADDR_IN);
  int sckt_n;
  SOCKADDR_IN serv_addr;
  
  while(1)
    {
      if((sckt_n = accept(sckt, (SOCKADDR*)&serv_addr, &addr_sz))==-1)
	{
	  perror("Error");
	  pthread_exit(-1);
	}

      switch(fork())
	{
	case -1:
	  perror("Error");
	  exit(EXIT_FAILURE);     
	case 0:
	  close(sckt_s);
	  //lo que sea
	  close(sckt_c);
	  return 0;
	default:
	  close(sckt_c);
	}
    }

  
}
